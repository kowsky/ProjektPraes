\documentclass[xcolor=dvipsnames, aspectratio=1610]{beamer}

\usetheme[1610]{ZBH}
\usepackage{graphicx}
\usepackage{algpseudocode}
\usepackage{numprint}
\usepackage[utf8]{inputenc}

\definecolor{greyish}{rgb}{224,224,224}
\setbeamertemplate{blocks}[rounded]
\setbeamercolor{block title}{fg=white,bg=MidnightBlue}
\setbeamercolor{block body}{fg=black,bg=lightgray!50}
       
\author{Meike Bruns, Florian Markowsky, Michael Spohn}
\title{Proteinsequenz-Vergleich mit KSEARCH und SANS}
\date{\today}

\AtBeginSubsection []
 {
  \begin{frame} 
    \frametitle{Gliederung}
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\begin{document}

%\titlepage
%\end{frame}

\maketitle

\begin{frame}
	\frametitle{Gliederung}
	\tableofcontents
\end{frame}

\section{Konzept}

\begin{frame}{Sequenzvergleiche}
  \begin{itemize}
    \item Die Bestimmung von Ähnlichkeiten zwischen Sequenzen ist eine häufige Aufgabe bei der Sequenzanalyse 
    \item Exakte Sequenzvergleiche sind oft zu zeitaufwändig 
  \end{itemize}
\end{frame}

\begin{frame}{Sequenzvergleiche - Methoden}
  \begin{itemize}
    \item Alignmentbasierte Methoden
      \begin{itemize}
        \item SSEARCH\\
              - ermittelt optimale lokale Alignments mittels Smith-Waterman-Algorithmus
        \item FASTA\\
              - verbindet HotSpots zu approximativen Alignments
        \item BLAST\\
              - erweitert Hits zu Maximum Segment Pairs
      \end{itemize}
    \item Ranking mittels Feature-Vektoren
      \begin{itemize}
        \item USEARCH\\
              - Vorsortieren der Datenbank nach Anzahlen gemeinsamer Teilwörter, Abbruch der Suche nach erstem Hit
        \item KSEARCH\\
              - bewertet Sequenzpaare aufgrund gemeinsamer k-mere
        \item SANS
              - bewertet Sequenzpaare aufgrund potentieller gemeinsamer Substrings
      \end{itemize}
      \item Aufgrund interesting similarities extend higher levels of mismathches sind Proteinanalysen mit suffixarrays nicht so verbreitet
  \end{itemize}
\end{frame}

\section{Algorithmen}

\subsection{Software Architektur}

\begin{frame}{Genometools}
  \begin{itemize}
    \item Wir implementieren in der Softwareumgebung Genometools, aus der wir eine Anzahl an Tools nutzen:
    \begin{itemize}
      \item encseq encode - ...
      \item suffixerator -
      \item kmer iterator -
    \end{itemize}    
  \end{itemize}
\end{frame}

\begin{frame}{Seqscore Toolbox}
  hier kommt die grafik mit der toolbox-struktur hin
\end{frame}

\begin{frame}{bla\_seqscore.c}
  hier kommt dir grafik mit der seqscore.c struktur hin: konstruktoren + berechnungsfunktionen
\end{frame}

\begin{frame}{Berechnungs-Aufruf}
  hier kommt die grafir mit dem berechnungs-aufruf hin: auf ruf der funktion mit callback, befuellen der ergebnis-struktur mit eben dieser
\end{frame}

\subsection{Datenstrukturen}

\begin{frame}{Suffixarrays}
  \begin{itemize}
    \item Enthalten alle Suffixe einer Sequenz in lexikographischer Ordnung
  \end{itemize}
  \begin{block}{Beispiel}
    \begin{columns}
      \column{.4\textwidth}
        Sequenz = GYBLAAB\$
      \scriptsize\column{.5\textwidth}
        Suffixarray:\\
        AAB\$\\
        AB\$\\
        BLAAB\$\\
        B\$\\
        GYBLAAB\$\\
        LAAB\$\\
        YBLAAB\$\\
        \$\\
      \normalsize
    \end{columns}
  \end{block}
\end{frame}

\subsection{KSEARCH}

\begin{frame}{KSEARCH - Berechnen der Scores}
  \begin{equation*}
    KSEARCH(query,database) = \sum_{u \in \mathcal A^k} F(query,u) \cdot F(database,u) NOTATION AUS GSA!!
  \end{equation*}  
  \begin{block}{Beispiel}
    \begin{columns}
    \column{.4\textwidth}
    query = BITQAPS\\
    database = PQAPSQAP\\  
    \column{.5\textwidth}  
    \scriptsize\begin{tabular}{cccc}
    kmer & query & database & Produkt\\
    APS & 1 & 1 & 1\\
    BIT & 1 & 0 & 0\\
    ITQ & 1 & 0 & 0 \\
    PQA & 0 & 1 & 0\\
    PSQ & 0 & 1 & 0\\
    QAP & 1 & 2 & 2\\
    SQA & 0 & 1 & 0\\
    TQA & 1 & 0 & 0\\    
    \end{tabular}
    \normalsize
    \end{columns}
  \end{block}
\end{frame}

\begin{frame}{Notation}
  \begin{itemize}
    \item $Q$ bzw. $D$ - Menge der Query- bzw. Datenbank-Proteine
    \item $q$ bzw. $d$ - ein Query- bzw. Datenbank-Protein
    \item $|Q|$ bzw. $|D|$- Anzahl der Query- bzw. Datenbank-Proteine
    \item $|q|$ bzw. $|d|$ - Länge eines Query- bzw. Datenbank-Proteins
    \item $|q_0..q_n|$ bzw. $|d_0..d_n|$ - Länge aller konkatenierten Query- bzw. Datenbank-Proteine
    \item $kVariety(q)$ bzw. $kVariety(d)$ - Anzahl untersciedlicher kmere in einem Query- bzw. Datenbank-Protein
  \end{itemize}
\end{frame}

\begin{frame}{KSEARCH}
 \begin{algorithmic}
   \Function{KSEARCH}{query-proteins $Q$, database-proteins $D$}
      \For{each query-protein $q$} 
        \State calculate kmer-profile \# $O(|q|)$
        \State store kmer-profile in hashtable
      \EndFor \Comment $O(|q_0..q_i|)$
       \For{each database-protein $d$}
         \State calculate kmer-profile  \# $O(|d|)$
         \For{i in $q_0..q_n$}
           \State calculate $KSEARCH(d,q_{i})$ \# $O(kVariety(d))$   
           \State output $KSEARCH(d,q)$ - score
         \EndFor
       \EndFor   \Comment $O(|d_0..d_i| \cdot ??? )$  
    \EndFunction
  \end{algorithmic}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Berechnung des KSEARCH-Scores mittels Suffixarrays
      \end{itemize}
    \item MMM
      \begin{itemize}
        \item Berechnung der KSEARCH-Scores mittels gehashter k-mer-Profilen
      \end{itemize}
    \end{itemize}
    
  \begin{tabular}{lcc}
     & Koskinen \& Holm & MMM\\
    Laufzeitkomplexität & $O(|d_0..d_n| \cdot |q_0..q_n|)$ & $O(|TXT|+|TXTQ| + Num(Q)*Num(D)*kVariety(...)$\\
%    Speicherplatzbedarf & keine Angabe & $O(Num(Q)\cdotNum(D)+Num(Q)\cdotkVariety(q))$
  \end{tabular}
\end{frame}

\begin{frame}{Optimierungsmöglichkeiten/Probleme KSEARCH}
  \begin{itemize}
    \item k-mer Profile zunächst als Matrix gespeichert: zu hoher Speicherbedarf
    \item Implementierung mit doppelter For-Schleife: zu hohe Laufzeit
  \end{itemize}
\end{frame}

\subsection{SANS}

\begin{frame}{SANS - Berechnen der Scores}
  \begin{itemize}
    \item Substrings von Sequenzen, die im Suffixarray nebeneinander liegen, haben typischerweise lange gemeinsame Präfixe
    \item  SANS-Scores bewerten Proteinpaare aufgrund von Nachbarschaften im Suffixarray
  \end{itemize}
  
  Beispielbild!
%  \begin{figure}
%        \includegraphics<1>[width=2cm,height=3.5cm]{First.eps}
%        \includegraphics<2>[width=2cm,height=3.5cm]{Second.eps}
%        \caption<1>{\only<1>{First Image}\only<2>{Second Image}}
%        %\caption<2>{Second Image}
%    \end{figure} 
\end{frame}

\begin{frame}{SANS}
 \begin{algorithmic}
   \Function{SANS}{query proteins $Q$, database proteins $D$, windowsize $h$}
     \State calculate $suffixarray_Q$ for query proteins \Comment $O(|d_0..d_i|)$
     \State calculate $suffixarray_D$ for database proteins \Comment $O(|q_0..q_i|)$
     \State initialize score matrix \Comment $O(|Q|\cdot|D|)$
     \State initialize $position = 0$
     \For{each $suffix_{qx}$ from 0 - $suffixarray_Q$.length}
       \State  $position$ = \Call {findPosition}{$suffix$, $suffixarray_D$, $position$} 
       \State shift $2h$ window over $position$ 
       \For{each $suffix_{dx}$ in window}
         \State update SANS-scores for  $(q_x,d_x)$
       \EndFor
     \EndFor \Comment $O(|q_0..q_i|\cdot2h + |d_0..d_i|)$ besser verteilen?
    \EndFunction  \Comment overall time complexity: $O(|q_0..q_i|\cdot2h + |d_0..d_i|+|Q|\cdot|D|)$ 2h raus?
  \end{algorithmic}
\end{frame}

\begin{frame}{findPosition}
  \begin{algorithmic}
    \Function{findPosition}{$suffix$, $suffixarray_D$, $position$}
      \For{$i$ in $position$..$suffixarray_D$.length}
        \If{$suffix$ fits in $i$}
          \State return $i$ 
        \EndIf
      \EndFor 
    \EndFunction
  \end{algorithmic} 
\end{frame}

\begin{frame}{Optimierungsmöglichkeiten SANS}
  \begin{itemize}
    \item mergen der Suffixarrays statt for-schleifen.\\
          Zeitersparnis?    
  \end{itemize}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Ermitteln der Positionen durch Mergen der Suffixarrays
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung
      \begin{itemize}
        \item Ermitteln der Positionen durch for-Schleifen
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + Konstruktion der Suffixarrays
            \item Speicherplatzbedarf: $O(m \cdot n)$ + Platz für Suffixarrays
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Auswertung}
  \begin{frame} 
    \frametitle{Gliederung}
    \tableofcontents[currentsection]
  \end{frame}

\begin{frame}{Laufzeiten}
  \begin{itemize}
    \item Query: 1083 Rattus rattus Proteine von NCBI \tiny{\url{http://www.ncbi.nlm.nih.gov/protein}}
    \item \normalsize{Database: Swissprot-Datenbank} \tiny{\url{http://www.uniprot.org/downloads}}
  \end{itemize}
  \begin{tabular}{l|cccc}
    & Holm SANS & ZBH SANS & Holm KSEARCH & ZBH KSEARCH \\
    \hline
    Indexing & & & & \\
       Suche & & & & \\
  \end{tabular}
\end{frame}

\begin{frame}{Sensitivitaet}
  Hier kommt eine Sensitivity-Grafik wie die im Paper hin.
\end{frame}

\begin{frame}{AUC}
  Hier kommt eine AUC-Grafik hin
\end{frame}

\end{document}
