\documentclass[aspectratio=1610]{beamer}

\usetheme[1610]{ZBH}
\usepackage{graphicx}
\usepackage[noend]{algpseudocode}
\usepackage{numprint}
\usepackage[utf8]{inputenc}

\setbeamercolor{block body}{bg=lightgray}
\setbeamercolor{block title}{bg=blue}

\author{Meike Bruns, Florian Markowsky, Michael Spohn}
\title{Implementation of KSEARCH and SANS Algorithms in the genometools-environment}
\date{\today}

\begin{document}

%\btBeginSubsection []
 {
  \begin{frame} 
    \frametitle{Gliederung}
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\titlepage
%\end{frame}

\begin{frame}
	\frametitle{Outline}
	\tableofcontents
\end{frame}

\section{Concept}

%\begin{frame}{Sequence comparison}
%  \begin{itemize}
%    \item Determing similarity of sequences very important task in sequence analysis
%    \item Most commonly used: BLAST
%  \end{itemize}
%\end{frame}
%
% dasselbe:
%
\begin{frame}{Sequenzvergleiche}
  \begin{itemize}
    \item Die Bestimmung von Ähnlichkeiten zwischen Sequenzen ist eine häufige Aufgabe bei der Sequenzanalyse 
    \item Exakte Sequenzvergleiche sind oft zu zeitaufwändig
  \end{itemize}
\end{frame}

\begin{frame}{Sequenzvergleiche}
  \begin{itemize}
    \item Alignmentbasierte Methoden
      \begin{itemize}
        \item SSEARCH\\
              - ermittelt optimale lokale Alignments mittels Smith-Waterman-Algorithmus
        \item FASTA\\
              - verbindet HotSpots zu approximativen Alignments
        \item BLAST\\
              - erweitert Hits zu Maximum Segment Pairs
      \end{itemize}
    \item Ranking mittels Feature-Vektoren
      \begin{itemize}
        \item USEARCH\\
              - Flo?
        \item KSEARCH\\
              - bewertet Sequenzpaare aufgrund gemeinsamer k-mere
        \item SANS
              - bewertet Sequenzpaare aufgrund potentieller gemeinsamer Substrings
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Algorithms}

\subsection{KSEARCH}

%\begin{frame}{Idea}
%  \begin{itemize}
%    \item Count frequencies of kmers in query sequence
%    \item Compare to kmer frequencies of database entrys
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{Analysis}
%  \begin{itemize}
%    \item Runtime:
%    \item Space requirements:
%  \end{itemize}
%\end{frame}

\begin{frame}{Scoring - Funktion}
  \begin{equation*}
    KSEARCH(query,database) = \sum_{u \in \mathcal A^k} F(query,u) \cdot F(database,u)
  \end{equation*}  
  \begin{block}{Beispiel}
    \begin{columns}
    \column{.4\textwidth}
    query = BITQAPS\\
    database = PQAPSQAP\\  
    \column{.5\textwidth}  
    \scriptsize\begin{tabular}{cccc}
    kmer & query & database & Produkt\\
    APS & 1 & 1 & 1\\
    BIT & 1 & 0 & 0\\
    ITQ & 1 & 0 & 0 \\
    PQA & 0 & 1 & 0\\
    PSQ & 0 & 1 & 0\\
    QAP & 1 & 2 & 2\\
    SQA & 0 & 1 & 0\\
    TQA & 1 & 0 & 0\\    
    \end{tabular}
    \normalsize
    \end{columns}
  \end{block}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Berechnung des KSEARCH-Scores mittels Suffixarrays:
          \begin{itemize}
            \item Laufzeit: $O(|TXT|*|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung
      \begin{itemize}
        \item Berechnung der KSEARCH-Scores mittels k-mer-Profilen
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|+(m+n) \cdot |\mathcal A^k|+ Anzahl Qprots \cdot Anzahl Sprots \cdot 1)$ ???
            \item Speicherplatzbedarf: $O(|Anzahl Qprots| \cdot \mathcal A^k + Anzahl Qprots \cdot Anzahl Sprots)$
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}


\subsection{SANS}
%\begin{frame}{Idea}
%  \begin{itemize}
%    \item Construct suffix tree for query sequence $q$
%    \item Construct suffix tree for database sequences
%    \item Merge suffix trees:
%      \begin{itemize}
%        \item for each suffix of $q$
%      \end{itemize}
%  \end{itemize}
%\end{frame}

\begin{frame}{Idee}
  \begin{itemize}
    \item Substrings von Sequenzen, die im Suffixarray nebeneinander liegen, haben mit hoher Wahrscheinlichkeit gemeinsame Präfixe
    \item  SANS-Scores nutzen das aus, indem der Score aus den Positionen der Sequenzen im Suffixarray abgeleitet werden.
  \end{itemize}
%  \begin{figure}
%        \includegraphics<1>[width=2cm,height=3.5cm]{First.eps}
%        \includegraphics<2>[width=2cm,height=3.5cm]{Second.eps}
%        \caption<1>{\only<1>{First Image}\only<2>{Second Image}}
%        %\caption<2>{Second Image}
%    \end{figure} 
\end{frame}

\begin{frame}
  \begin{equation*}
    SANS(qprot,sprot) = \sum_{s=START[qprot]}^{START[qprot+1]-1} \sum_{i=-w}^{+w} id(sprot,SAP[ISA_{mapped}[s]+i]) 
  \end{equation*}

  Mit der Identitätsfunktion

  \begin{equation*}
    id(a,b)=\begin{cases}
      1, & if~a=b\\
      0, & if~a\ne b\\
    \end{cases}
  \end{equation*}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Ermitteln der Positionen durch Mergen der Suffixarrays
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung
      \begin{itemize}
        \item Ermitteln der Positionen durch for-Schleifen
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + Konstruktion der Suffixarrays
            \item Speicherplatzbedarf: $O(m \cdot n)$ + Platz für Suffixarrays
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Implementation}

\subsection{Our implementation}

\begin{frame}{KSEARCHER}
%  \begin{algorithmic}
%    \Function{KSEARCHER}{query-proteins, database-proteins}
%      \For{each query-protein} 
%        \State calculate kmer-profile
%        \State save kmer-profile in matrix
%      \EndFor
%      \For{each database-protein} 
%    \EndFunction
%  \end{algorithmic}
\end{frame}





























































\begin{frame}{genometools}
\end{frame}

\subsection{Comparison to developers implementation}

\begin{frame}{}
\end{frame}

\end{document}
