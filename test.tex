\documentclass[aspectratio=1610]{beamer}

\usetheme[1610]{ZBH}
\usepackage{graphicx}
\usepackage[noend]{algpseudocode}
\usepackage{numprint}
\usepackage[utf8]{inputenc}

\setbeamercolor{block body}{bg=lightgray}
\setbeamercolor{block title}{bg=blue}

\author{Meike Bruns, Florian Markowsky, Michael Spohn}
\title{Proteinsequenz-Vergleich mit KSEARCH und SANS}
\date{\today}

\AtBeginSubsection []
 {
  \begin{frame} 
    \frametitle{Gliederung}
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\begin{document}

%\titlepage
%\end{frame}

\maketitle

\begin{frame}
	\frametitle{Gliederung}
	\tableofcontents
\end{frame}

\section{Konzept}

\begin{frame}{Sequenzvergleiche}
  \begin{itemize}
    \item Die Bestimmung von Ähnlichkeiten zwischen Sequenzen ist eine häufige Aufgabe bei der Sequenzanalyse 
    \item Exakte Sequenzvergleiche sind oft zu zeitaufwändig
    \item Bei Proteinsequenzen sind auf exakten Matches basierende Vergleiche umstritten
  \end{itemize}
\end{frame}

\begin{frame}{Sequenzvergleiche - Methoden}
  \begin{itemize}
    \item Alignmentbasierte Methoden
      \begin{itemize}
        \item SSEARCH\\
              - ermittelt optimale lokale Alignments mittels Smith-Waterman-Algorithmus
        \item FASTA\\
              - verbindet HotSpots zu approximativen Alignments
        \item BLAST\\
              - erweitert Hits zu Maximum Segment Pairs
      \end{itemize}
    \item Ranking mittels Feature-Vektoren
      \begin{itemize}
        \item USEARCH\\
              - Vorsortieren der Datenbank nach Anzahlen gemeinsamer Teilwörter, Abbruch der Suche nach erstem Hit
        \item KSEARCH\\
              - bewertet Sequenzpaare aufgrund gemeinsamer k-mere
        \item SANS
              - bewertet Sequenzpaare aufgrund potentieller gemeinsamer Substrings
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Algorithmen}

\subsection{Software Architektur}

\begin{frame}{Genometools}
  \begin{itemize}
    \item Wir implementieren in der Softwareumgebung Genometools, aus der wir eine Anzahl an Tools nutzen:
    \begin{itemize}
      \item encseq encode - ...
      \item suffixerator -
      \item kmer iterator -
    \end{itemize}    
  \end{itemize}
\end{frame}

\begin{frame}{Seqscore Toolbox}
  hier kommt die grafik mit der toolbox-struktur hin
\end{frame}

\begin{frame}{bla\_seqscore.c}
  hier kommt dir grafik mit der seqscore.c struktur hin: konstruktoren + berechnungsfunktionen
\end{frame}

\begin{frame}{Berechnungs-Aufruf}
  hier kommt die grafir mit dem berechnungs-aufruf hin: auf ruf der funktion mit callback, befuellen der ergebnis-struktur mit eben dieser
\end{frame}

\subsection{Datenstrukturen}

\begin{frame}{Suffixarrays}
  \begin{itemize}
    \item Enthalten alle Suffixe einer Sequenz in lexikographischer Ordnung
  \end{itemize}
  \begin{block}{Beispiel}
    \begin{columns}
      \column{.4\textwidth}
        Sequenz = GYBLAAB\$
      \scriptsize\column{.5\textwidth}
        Suffixarray:\\
        AAB\$\\
        AB\$\\
        BLAAB\$\\
        B\$\\
        GYBLAAB\$\\
        LAAB\$\\
        YBLAAB\$\\
        \$\\
      \normalsize
    \end{columns}
  \end{block}
\end{frame}

\subsection{KSEARCH}

\begin{frame}{KSEARCH - Berechnen der Scores}
  \begin{equation*}
    KSEARCH(query,database) = \sum_{u \in \mathcal A^k} F(query,u) \cdot F(database,u)
  \end{equation*}  
  \begin{block}{Beispiel}
    \begin{columns}
    \column{.4\textwidth}
    query = BITQAPS\\
    database = PQAPSQAP\\  
    \column{.5\textwidth}  
    \scriptsize\begin{tabular}{cccc}
    kmer & query & database & Produkt\\
    APS & 1 & 1 & 1\\
    BIT & 1 & 0 & 0\\
    ITQ & 1 & 0 & 0 \\
    PQA & 0 & 1 & 0\\
    PSQ & 0 & 1 & 0\\
    QAP & 1 & 2 & 2\\
    SQA & 0 & 1 & 0\\
    TQA & 1 & 0 & 0\\    
    \end{tabular}
    \normalsize
    \end{columns}
  \end{block}
\end{frame}

\begin{frame}{KSEARCH}
 \begin{algorithmic}
   \Function{KSEARCH}{query-proteins, database-proteins}
      \For{each database-protein d} 
        \State calculate kmer-profile
         \For{each query-protein q}
           \State calculate kmer-profile
           \State calculate KSEARCH(d,q) - score:
           \State score = 0
           \For{each possible kmer}
             \State score calculation??
           \EndFor
         \State output KSEARCH(d,q) - score
         \EndFor
      \EndFor     
    \EndFunction
  \end{algorithmic}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Berechnung des KSEARCH-Scores mittels Suffixarrays:
          \begin{itemize}
            \item Laufzeit: $O(|TXT|*|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung:
      \begin{itemize}
        \item Berechnung der KSEARCH-Scores mittels gehashter k-mer-Profilen (hier kurz erläutern, was das ist!)
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|+(m+n) \cdot |\mathcal A^k|+ Anzahl Qprots \cdot Anzahl Sprots \cdot 1)$ ??? LAUFZEIT JETZT ANDERS!!!
            \item Speicherplatzbedarf: $O(|Anzahl Qprots| \cdot \mathcal A^k + Anzahl Qprots \cdot Anzahl Sprots)$
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Optimierungsmöglichkeiten/Probleme KSEARCH}
  \begin{itemize}
    \item verkettete Liste. dadurch keine 2 geschachtelten for-schleifen\\
          Zeitersparnis?
    \item Zu hoher Speicherbedarf durch Matrix
  \end{itemize}
\end{frame}

\subsection{SANS}

\begin{frame}{SANS - Berechnen der Scores}
  \begin{itemize}
    \item Substrings von Sequenzen, die im Suffixarray nebeneinander liegen, haben mit hoher Wahrscheinlichkeit gemeinsame Präfixe
    \item  SANS-Scores nutzen das aus, indem der Score aus den Positionen der Sequenzen im Suffixarray abgeleitet werden.
  \end{itemize}
  
  Beispielbild!
%  \begin{figure}
%        \includegraphics<1>[width=2cm,height=3.5cm]{First.eps}
%        \includegraphics<2>[width=2cm,height=3.5cm]{Second.eps}
%        \caption<1>{\only<1>{First Image}\only<2>{Second Image}}
%        %\caption<2>{Second Image}
%    \end{figure} 
\end{frame}

\begin{frame}{SANS}
 \begin{algorithmic}
   \Function{SANS}{query proteins, database proteins}
     \State calculate suffixarray for query proteins
     \State calculate suffixarray for database proteins
     \State initialize score matrix
     \For{each suffix entry from 0 - query suffixarray.length}
       \State find position in database suffixarray:
       \State current position = 0
       \For{i in current position - database suffixarray.length}
         \If{suffix entry fits in at position i}
           \State calculate scores for proteinpairs inside window  BESSER FORMULIEREN!
           \State update score matrix 
           \State current position = i
         \EndIf
       \EndFor
     \EndFor
    \EndFunction
  \end{algorithmic} 
\end{frame}

\begin{frame}{Optimierungsmöglichkeiten SANS}
  \begin{itemize}
    \item mergen der Suffixarrays statt for-schleifen.\\
          Zeitersparnis?    
  \end{itemize}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Ermitteln der Positionen durch Mergen der Suffixarrays
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung
      \begin{itemize}
        \item Ermitteln der Positionen durch for-Schleifen
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + Konstruktion der Suffixarrays
            \item Speicherplatzbedarf: $O(m \cdot n)$ + Platz für Suffixarrays
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Auswertung}
  \begin{frame} 
    \frametitle{Gliederung}
    \tableofcontents[currentsection]
  \end{frame}

\begin{frame}{Laufzeiten}
  \begin{itemize}
    \item Query: 1083 Rattus rattus Proteine von NCBI \tiny{\url{http://www.ncbi.nlm.nih.gov/protein}}
    \item \normalsize{Database: Swissprot-Datenbank} \tiny{\url{http://www.uniprot.org/downloads}}
  \end{itemize}
  \begin{tabular}{l|cccc}
    & Holm SANS & ZBH SANS & Holm KSEARCH & ZBH KSEARCH \\
    \hline
    Indexing & & & & \\
       Suche & & & & \\
  \end{tabular}
\end{frame}

\begin{frame}{Sensitivitaet}
  Hier kommt eine Sensitivity-Grafik wie die im Paper hin.
\end{frame}

\begin{frame}{AUC}
  Hier kommt eine AUC-Grafik hin
\end{frame}

\end{document}
