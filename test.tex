\documentclass[aspectratio=1610]{beamer}

\usetheme[1610]{ZBH}
\usepackage{graphicx}
\usepackage[noend]{algpseudocode}
\usepackage{numprint}
\usepackage[utf8]{inputenc}

\setbeamercolor{block body}{bg=lightgray}
\setbeamercolor{block title}{bg=blue}

\author{Meike Bruns, Florian Markowsky, Michael Spohn}
\title{Implementation of KSEARCH and SANS Algorithms in the genometools-environment}
\date{\today}

\AtBeginSubsection []
 {
  \begin{frame} 
    \frametitle{Gliederung}
    \tableofcontents[currentsection, currentsubsection]
  \end{frame}
}

\begin{document}

%\titlepage
%\end{frame}

\maketitle

\begin{frame}
	\frametitle{Gliederung}
	\tableofcontents
\end{frame}

\section{Konzept}

\begin{frame}{Sequenzvergleiche}
  \begin{itemize}
    \item Die Bestimmung von Ähnlichkeiten zwischen Sequenzen ist eine häufige Aufgabe bei der Sequenzanalyse 
    \item Exakte Sequenzvergleiche sind oft zu zeitaufwändig
  \end{itemize}
\end{frame}

\begin{frame}{Sequenzvergleiche - Methoden}
  \begin{itemize}
    \item Alignmentbasierte Methoden
      \begin{itemize}
        \item SSEARCH\\
              - ermittelt optimale lokale Alignments mittels Smith-Waterman-Algorithmus
        \item FASTA\\
              - verbindet HotSpots zu approximativen Alignments
        \item BLAST\\
              - erweitert Hits zu Maximum Segment Pairs
      \end{itemize}
    \item Ranking mittels Feature-Vektoren
      \begin{itemize}
        \item USEARCH\\
              - Vorsortieren der Datenbank nach Anzahlen gemeinsamer Teilwörter, Abbruch der Suche nach erstem Hit
        \item KSEARCH\\
              - bewertet Sequenzpaare aufgrund gemeinsamer k-mere
        \item SANS
              - bewertet Sequenzpaare aufgrund potentieller gemeinsamer Substrings
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Algorithmen}

\subsection{Datenstrukturen}

\begin{frame}{Suffixarrays}
  \begin{itemize}
    \item Enthalten alle Suffixe einer Sequenz in lexikographischer Ordnung
  \end{itemize}
  \begin{block}{Beispiel}
    \begin{columns}
      \column{.4\textwidth}
        Sequenz = GYBLAAB\$
      \scriptsize\column{.5\textwidth}
        Suffixarray:\\
        AAB\$\\
        AB\$\\
        BLAAB\$\\
        B\$\\
        GYBLAAB\$\\
        LAAB\$\\
        YBLAAB\$\\
        \$\\
      \normalsize
    \end{columns}
  \end{block}
\end{frame}

\subsection{KSEARCH}

\begin{frame}{KSEARCH - Berechnen der Scores}
  \begin{equation*}
    KSEARCH(query,database) = \sum_{u \in \mathcal A^k} F(query,u) \cdot F(database,u)
  \end{equation*}  
  \begin{block}{Beispiel}
    \begin{columns}
    \column{.4\textwidth}
    query = BITQAPS\\
    database = PQAPSQAP\\  
    \column{.5\textwidth}  
    \scriptsize\begin{tabular}{cccc}
    kmer & query & database & Produkt\\
    APS & 1 & 1 & 1\\
    BIT & 1 & 0 & 0\\
    ITQ & 1 & 0 & 0 \\
    PQA & 0 & 1 & 0\\
    PSQ & 0 & 1 & 0\\
    QAP & 1 & 2 & 2\\
    SQA & 0 & 1 & 0\\
    TQA & 1 & 0 & 0\\    
    \end{tabular}
    \normalsize
    \end{columns}
  \end{block}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Berechnung des KSEARCH-Scores mittels Suffixarrays:
          \begin{itemize}
            \item Laufzeit: $O(|TXT|*|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung
      \begin{itemize}
        \item Berechnung der KSEARCH-Scores mittels k-mer-Profilen (hier kurz erläutern, was das ist!)
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|+(m+n) \cdot |\mathcal A^k|+ Anzahl Qprots \cdot Anzahl Sprots \cdot 1)$ ??? LAUFZEIT JETZT ANDERS!!!
            \item Speicherplatzbedarf: $O(|Anzahl Qprots| \cdot \mathcal A^k + Anzahl Qprots \cdot Anzahl Sprots)$
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}


\subsection{SANS}

\begin{frame}{SANS - Berechnen der Scores}
  \begin{itemize}
    \item Substrings von Sequenzen, die im Suffixarray nebeneinander liegen, haben mit hoher Wahrscheinlichkeit gemeinsame Präfixe
    \item  SANS-Scores nutzen das aus, indem der Score aus den Positionen der Sequenzen im Suffixarray abgeleitet werden.
  \end{itemize}
  
  Beispielbild!
%  \begin{figure}
%        \includegraphics<1>[width=2cm,height=3.5cm]{First.eps}
%        \includegraphics<2>[width=2cm,height=3.5cm]{Second.eps}
%        \caption<1>{\only<1>{First Image}\only<2>{Second Image}}
%        %\caption<2>{Second Image}
%    \end{figure} 
\end{frame}

\begin{frame}

eventuell kann diese Folie raus. wenn nicht, Formel schöner machen!
  \begin{equation*}
    SANS(qprot,sprot) = \sum_{s=START[qprot]}^{START[qprot+1]-1} \sum_{i=-w}^{+w} id(sprot,SAP[ISA_{mapped}[s]+i]) 
  \end{equation*}

  Mit der Identitätsfunktion

  \begin{equation*}
    id(a,b)=\begin{cases}
      1, & if~a=b\\
      0, & if~a\ne b\\
    \end{cases}
  \end{equation*}
\end{frame}

\begin{frame}{Implementierungsansatz und Analyse}
  \begin{itemize}
    \item Koskinen \& Holm
      \begin{itemize}
        \item Ermitteln der Positionen durch Mergen der Suffixarrays
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + lineare Konstruktion der Suffixarrays
            \item Speicherplatzbedarf:
          \end{itemize}
      \end{itemize}
    \item Unsere Implementierung
      \begin{itemize}
        \item Ermitteln der Positionen durch for-Schleifen
          \begin{itemize}
            \item Laufzeit: $O(|TXT|+|TXT_Q|)$ + Konstruktion der Suffixarrays
            \item Speicherplatzbedarf: $O(m \cdot n)$ + Platz für Suffixarrays
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Implementation}

\subsection{Genometools}

\begin{frame}{Genometools}
  \begin{itemize}
    \item Wir implementieren in der Softwareumgebung Genometools, aus der wir eine Anzahl an Tools nutzen:
    \begin{itemize}
      \item encseq encode - ...
      \item suffixerator -
      \item kmer iterator -
    \end{itemize}    
  \end{itemize}
\end{frame}

\subsection{Our implementation}

\begin{frame}{KSEARCH}
 \begin{algorithmic}
   \Function{KSEARCH}{query-proteins, database-proteins}
      \For{each database-protein d} 
        \State calculate kmer-profile
         \For{each query-protein q}
           \State calculate kmer-profile
           \State calculate KSEARCH(d,q) - score:
           \State score = 0
           \For{each possible kmer}
             \State score calculation??
           \EndFor
         \State output KSEARCH(d,q) - score
         \EndFor
      \EndFor     
    \EndFunction
  \end{algorithmic}
\end{frame}

\begin{frame}{Optimierungsmöglichkeiten KSEARCH}
  \begin{itemize}
    \item verkettete Liste. dadurch keine 2 geschachtelten for-schleifen\\
          Zeitersparnis?
  \end{itemize}
\end{frame}

\begin{frame}{SANS}
 \begin{algorithmic}
   \Function{SANS}{query proteins, database proteins}
     \State calculate suffixarray for query proteins
     \State calculate suffixarray for database proteins
     \State initialize score matrix
     \For{each suffix entry from 0 - query suffixarray.length}
       \State find position in database suffixarray:
       \State current position = 0
       \For{i in current position - database suffixarray.length}
         \If{suffix entry fits in at position i}
           \State calculate scores for proteinpairs inside window  BESSER FORMULIEREN!
           \State update score matrix 
           \State current position = i
         \EndIf
       \EndFor
     \EndFor
    \EndFunction
  \end{algorithmic} 
\end{frame}

\begin{frame}{Optimierungsmöglichkeiten SANS}
  \begin{itemize}
    \item mergen der Suffixarrays statt for-schleifen.\\
          Zeitersparnis?    
  \end{itemize}
\end{frame}

\begin{frame}{Vergleich mit Koskinen \& Holm}

hier nochmal? Folie von oben runter?? oder ist das schon der Analyseteil??

wo kommt das mit den 1,2,3 bzw. 1,3,5 -repeats hin?
\end{frame}

\begin{frame}{Laufzeiten}
  \begin{itemize}
    \item 1000 Rattus rattus Proteine gegen Swissprot-Datenbank
  \end{itemize}
  \begin{tabular}{l|ccccc}
    & Holm SANS & ZBH SANS & Holm KSEARCH & ZBH KSEARCH & BLAST\\
    \hline
    Index-Erstellung & & & & & \\
             Scoring & & & & & \\
  \end{tabular}
\end{frame}

\begin{frame}{Spezifität}
  Hier kommt eine Grafik wie die im Paper hin.
\end{frame}

\end{document}
